// === 8-bit TCAM Comparator ===
module tcam_line2 #(parameter KEY_WIDTH = 8)(
    input [KEY_WIDTH-1:0] key,
    input [KEY_WIDTH-1:0] stored_key,
    input [KEY_WIDTH-1:0] xmask,
    output match
);
    assign match = ~|((key ^ stored_key) & ~xmask);
endmodule

// === Main Module: Bit_128to8 ===
module Bit_128to8_New (
    input clk,
    input rst,
    input start,
    input [127:0] unsorted_data,
    input [7:0] search_key,
    input [7:0] xmask,
    output reg [127:0] sorted_data,
    output reg [3:0] match_lines,
    output reg [7:0] sorted_indices,
    output reg [127:0] memory_out,
    output reg [127:0] byte_sorted_data,
    output reg [31:0] byte_sorted_indices,
    output [31:0] major_sorted_data_0,
    output [31:0] major_sorted_data_1,
    output [31:0] major_sorted_data_2,
    output [31:0] major_sorted_data_3,
    output [7:0] major_sorted_idx_0,
    output [7:0] major_sorted_idx_1,
    output [7:0] major_sorted_idx_2,
    output [7:0] major_sorted_idx_3,
    output reg done
);

    reg [31:0] data_array [0:3];
    reg [1:0] index_array [0:3];
    reg [1:0] compare_idx, pass_count, state;
    reg [31:0] temp;
    reg [1:0] temp_index;
    reg [31:0] memory [0:3];

    localparam IDLE = 2'b00, LOAD = 2'b01, SORT = 2'b10, WAIT_BYTE_SORT = 2'b11;

    wire [31:0] sorted_bytes [0:3];
    wire [7:0] byte_indices [0:3];
    wire [3:0] done_bytes;
    wire [3:0] dummy_match;
    wire [7:0] dummy_unsorted;

    reg [31:0] major0, major1, major2, major3;

    function [7:0] get_byte;
        input [31:0] word;
        input [1:0] idx;
        begin
            case (idx)
                2'd0: get_byte = word[31:24];
                2'd1: get_byte = word[23:16];
                2'd2: get_byte = word[15:8];
                2'd3: get_byte = word[7:0];
                default: get_byte = 8'd0;
            endcase
        end
    endfunction

    function compare_words;
        input [31:0] a, b;
        reg [7:0] byte_a, byte_b;
        integer i;
        reg done_flag;
        begin
            compare_words = 0;
            done_flag = 0;
            for (i = 3; i >= 0; i = i - 1) begin
                if (!done_flag) begin
                    byte_a = get_byte(a, i) & ~xmask;
                    byte_b = get_byte(b, i) & ~xmask;
                    if (byte_a > byte_b) begin
                        compare_words = 1;
                        done_flag = 1;
                    end else if (byte_a < byte_b) begin
                        compare_words = 0;
                        done_flag = 1;
                    end
                end
            end
        end
    endfunction

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            sorted_data <= 0;
            sorted_indices <= 0;
            memory_out <= 0;
            byte_sorted_data <= 0;
            byte_sorted_indices <= 0;
            done <= 0;
            compare_idx <= 0;
            pass_count <= 0;
            state <= IDLE;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                    if (start) state <= LOAD;
                end
                LOAD: begin
                    data_array[0] <= unsorted_data[31:0];
                    data_array[1] <= unsorted_data[63:32];
                    data_array[2] <= unsorted_data[95:64];
                    data_array[3] <= unsorted_data[127:96];
                    index_array[0] <= 2'd0;
                    index_array[1] <= 2'd1;
                    index_array[2] <= 2'd2;
                    index_array[3] <= 2'd3;
                    compare_idx <= 0;
                    pass_count <= 0;
                    state <= SORT;
                end
                SORT: begin
                    if (compare_idx < 3) begin
                        if (compare_words(data_array[compare_idx], data_array[compare_idx + 1])) begin
                            temp = data_array[compare_idx];
                            data_array[compare_idx] = data_array[compare_idx + 1];
                            data_array[compare_idx + 1] = temp;

                            temp_index = index_array[compare_idx];
                            index_array[compare_idx] = index_array[compare_idx + 1];
                            index_array[compare_idx + 1] = temp_index;
                        end
                        compare_idx <= compare_idx + 1;
                    end else begin
                        compare_idx <= 0;
                        pass_count <= pass_count + 1;
                        if (pass_count >= 3) state <= WAIT_BYTE_SORT;
                    end
                end
                WAIT_BYTE_SORT: begin
                    sorted_data <= {data_array[3], data_array[2], data_array[1], data_array[0]};
                    sorted_indices <= {index_array[3], index_array[2], index_array[1], index_array[0]};
                    memory[0] <= data_array[0];
                    memory[1] <= data_array[1];
                    memory[2] <= data_array[2];
                    memory[3] <= data_array[3];
                    memory_out <= {memory[3], memory[2], memory[1], memory[0]};

                    // Capture the MSBs for byte-wise sorting
                    major0 <= {data_array[0][31:24], data_array[1][31:24], data_array[2][31:24], data_array[3][31:24]};
                    major1 <= {data_array[0][23:16], data_array[1][23:16], data_array[2][23:16], data_array[3][23:16]};
                    major2 <= {data_array[0][15:8],  data_array[1][15:8],  data_array[2][15:8],  data_array[3][15:8]};
                    major3 <= {data_array[0][7:0],   data_array[1][7:0],   data_array[2][7:0],   data_array[3][7:0]};

                    if (&done_bytes) begin
                        byte_sorted_data <= {sorted_bytes[3], sorted_bytes[2], sorted_bytes[1], sorted_bytes[0]};
                        byte_sorted_indices <= {byte_indices[3], byte_indices[2], byte_indices[1], byte_indices[0]};
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end

    // TCAM match line logic
    wire [3:0] match_msb0, match_msb1, match_msb2, match_msb3;
    genvar idx;
    generate
        for (idx = 0; idx < 4; idx = idx + 1) begin : tcam_gen
            tcam_line2 t0 (.key(search_key), .stored_key(data_array[idx][31:24]), .xmask(xmask), .match(match_msb0[idx]));
            tcam_line2 t1 (.key(search_key), .stored_key(data_array[idx][23:16]), .xmask(xmask), .match(match_msb1[idx]));
            tcam_line2 t2 (.key(search_key), .stored_key(data_array[idx][15:8]),  .xmask(xmask), .match(match_msb2[idx]));
            tcam_line2 t3 (.key(search_key), .stored_key(data_array[idx][7:0]),   .xmask(xmask), .match(match_msb3[idx]));
        end
    endgenerate

    always @(*) begin
        match_lines[0] = match_msb0[0] | match_msb1[0] | match_msb2[0] | match_msb3[0];
        match_lines[1] = match_msb0[1] | match_msb1[1] | match_msb2[1] | match_msb3[1];
        match_lines[2] = match_msb0[2] | match_msb1[2] | match_msb2[2] | match_msb3[2];
        match_lines[3] = match_msb0[3] | match_msb1[3] | match_msb2[3] | match_msb3[3];
    end

    wire [31:0] major_sorted_data [0:3];
    wire [7:0] major_sorted_indices [0:3];
    wire [3:0] major_sort_done;
    wire [3:0] major_sort_match;

    assign major_sorted_data_0 = major_sorted_data[0];
    assign major_sorted_data_1 = major_sorted_data[1];
    assign major_sorted_data_2 = major_sorted_data[2];
    assign major_sorted_data_3 = major_sorted_data[3];
    assign major_sorted_idx_0 = major_sorted_indices[0];
    assign major_sorted_idx_1 = major_sorted_indices[1];
    assign major_sorted_idx_2 = major_sorted_indices[2];
    assign major_sorted_idx_3 = major_sorted_indices[3];

    // Byte sorters for each 32-bit word
    generate
        for (idx = 0; idx < 4; idx = idx + 1) begin : byte_sorters
            idx_sorted_32to8 byte_sort (
                .clk(clk), .rst(rst), .start(state == WAIT_BYTE_SORT),
                .unsorted_data(data_array[idx]),
                .search_key(search_key), .xmask(xmask),
                .sorted_data(sorted_bytes[idx]),
                .match_lines(dummy_match[idx]),
                .done(done_bytes[idx]),
                .sorted_indices(byte_indices[idx]),
                .unsorted_indices(dummy_unsorted)
            );
        end
    endgenerate

    // Major sorting by byte plane
    idx_sorted_32to8 sorter0 (.clk(clk), .rst(rst), .start(state == WAIT_BYTE_SORT),
        .unsorted_data(major0), .search_key(search_key), .xmask(xmask),
        .sorted_data(major_sorted_data[0]), .match_lines(major_sort_match[0]),
        .done(major_sort_done[0]), .sorted_indices(major_sorted_indices[0]),
        .unsorted_indices(dummy_unsorted));

    idx_sorted_32to8 sorter1 (.clk(clk), .rst(rst), .start(state == WAIT_BYTE_SORT),
        .unsorted_data(major1), .search_key(search_key), .xmask(xmask),
        .sorted_data(major_sorted_data[1]), .match_lines(major_sort_match[1]),
        .done(major_sort_done[1]), .sorted_indices(major_sorted_indices[1]),
        .unsorted_indices(dummy_unsorted));

    idx_sorted_32to8 sorter2 (.clk(clk), .rst(rst), .start(state == WAIT_BYTE_SORT),
        .unsorted_data(major2), .search_key(search_key), .xmask(xmask),
        .sorted_data(major_sorted_data[2]), .match_lines(major_sort_match[2]),
        .done(major_sort_done[2]), .sorted_indices(major_sorted_indices[2]),
        .unsorted_indices(dummy_unsorted));

    idx_sorted_32to8 sorter3 (.clk(clk), .rst(rst), .start(state == WAIT_BYTE_SORT),
        .unsorted_data(major3), .search_key(search_key), .xmask(xmask),
        .sorted_data(major_sorted_data[3]), .match_lines(major_sort_match[3]),
        .done(major_sort_done[3]), .sorted_indices(major_sorted_indices[3]),
        .unsorted_indices(dummy_unsorted));
endmodule
